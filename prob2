#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MAX_CLAVES = 3; // límite para dividir

// Nodo del árbol
class Pagina {
public:
    bool esHoja;
    vector<int> claves;
    vector<int> valores;   // solo hojas
    vector<Pagina*> hijos; // solo internos
    Pagina* siguiente;     // enlace entre hojas

    Pagina(bool hoja) : esHoja(hoja), siguiente(nullptr) {}
};

// Árbol B+
class BPlusTree {
private:
    Pagina* raiz;

    // Insertar en una hoja
    bool insertarEnHoja(Pagina* pag, int clave, int valor,
                        int &claveProm, Pagina* &nuevaHoja)
    {
        // insertar en orden
        auto it = lower_bound(pag->claves.begin(), pag->claves.end(), clave);
        int pos = it - pag->claves.begin();

        pag->claves.insert(it, clave);
        pag->valores.insert(pag->valores.begin() + pos, valor);

        // no excede
        if (pag->claves.size() <= MAX_CLAVES) return false;

        // dividir hoja
        int mid = pag->claves.size() / 2;
        nuevaHoja = new Pagina(true);

        nuevaHoja->claves.assign(pag->claves.begin() + mid, pag->claves.end());
        nuevaHoja->valores.assign(pag->valores.begin() + mid, pag->valores.end());

        pag->claves.resize(mid);
        pag->valores.resize(mid);

        nuevaHoja->siguiente = pag->siguiente;
        pag->siguiente = nuevaHoja;

        claveProm = nuevaHoja->claves.front();
        return true;
    }

    // Recursivo para insertar
    bool insertarRec(Pagina* pag, int clave, int valor,
                     int &claveProm, Pagina* &nuevoHijo)
    {
        // --- HOJA ---
        if (pag->esHoja) {
            return insertarEnHoja(pag, clave, valor, claveProm, nuevoHijo);
        }

        // --- INTERNO ---
        int i = 0;
        while (i < pag->claves.size() && clave >= pag->claves[i]) i++;

        int claveSube;
        Pagina* hijoNuevo = nullptr;

        bool dividido = insertarRec(pag->hijos[i], clave, valor,
                                    claveSube, hijoNuevo);

        if (!dividido) return false;

        // insertar clave y nuevo hijo
        pag->claves.insert(pag->claves.begin() + i, claveSube);
        pag->hijos.insert(pag->hijos.begin() + i + 1, hijoNuevo);

        if (pag->claves.size() <= MAX_CLAVES) return false;

        // dividir interno
        int mid = pag->claves.size() / 2;
        Pagina* nuevoInterno = new Pagina(false);

        claveProm = pag->claves[mid];

        nuevoInterno->claves.assign(pag->claves.begin() + mid + 1, pag->claves.end());
        nuevoInterno->hijos.assign(pag->hijos.begin() + mid + 1, pag->hijos.end());

        pag->claves.resize(mid);
        pag->hijos.resize(mid + 1);

        nuevoHijo = nuevoInterno;
        return true;
    }

public:
    BPlusTree() {
        raiz = new Pagina(true);
    }

    void insertar(int clave, int valor) {
        int claveProm;
        Pagina* nuevoHijo = nullptr;

        bool dividido = insertarRec(raiz, clave, valor, claveProm, nuevoHijo);

        // si la raíz se divide
        if (dividido) {
            Pagina* nuevaRaiz = new Pagina(false);
            nuevaRaiz->claves.push_back(claveProm);
            nuevaRaiz->hijos.push_back(raiz);
            nuevaRaiz->hijos.push_back(nuevoHijo);
            raiz = nuevaRaiz;
        }
    }

    bool buscar(int clave, int &valor) {
        Pagina* pag = raiz;

        // bajar hasta hoja
        while (!pag->esHoja) {
            int i = 0;
            while (i < pag->claves.size() && clave >= pag->claves[i]) i++;
            pag = pag->hijos[i];
        }

        // buscar en hoja
        for (int i = 0; i < pag->claves.size(); i++) {
            if (pag->claves[i] == clave) {
                valor = pag->valores[i];
                return true;
            }
        }
        return false;
    }
};

// Ejemplo
int main() {
    BPlusTree arbol;

    arbol.insertar(10, 100);
    arbol.insertar(5, 50);
    arbol.insertar(20, 200);
    arbol.insertar(15, 150);

    int valor;
    if (arbol.buscar(15, valor))
        cout << "15 -> " << valor << endl;

    return 0;
}
