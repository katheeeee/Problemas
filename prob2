#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MAX_CLAVES = 3; // límite para dividir

// Nodo del árbol
class Pagina {
public:
    bool esHoja;
    vector<int> claves;
    vector<int> valores;     // solo hojas
    vector<Pagina*> hijos;   // solo internos
    Pagina* siguiente;       // enlace entre hojas

    Pagina(bool hoja) : esHoja(hoja), siguiente(nullptr) {}
};

// Árbol B+
class BPlusTree {
private:
    Pagina* raiz;

    // Inserta en hojas
    bool insertarEnHoja(Pagina* pag, int clave, int valor,
                        int &claveProm, Pagina* &nuevaPag) 
    {
        auto it = lower_bound(pag->claves.begin(), pag->claves.end(), clave);
        int pos = it - pag->claves.begin();

        pag->claves.insert(it, clave);
        pag->valores.insert(pag->valores.begin() + pos, valor);

        if (pag->claves.size() <= MAX_CLAVES) return false;

        // dividir hoja
        int mid = pag->claves.size() / 2;
        nuevaPag = new Pagina(true);

        nuevaPag->claves.assign(pag->claves.begin() + mid, pag->claves.end());
        nuevaPag->valores.assign(pag->valores.begin() + mid, pag->valores.end());

        pag->claves.resize(mid);
        pag->valores.resize(mid);

        nuevaPag->siguiente = pag->siguiente;
        pag->siguiente = nuevaPag;

        claveProm = nuevaPag->claves.front();
        return true;
    }

    // Inserta recursivamente
    bool insertarRec(Pagina* pag, int clave, int valor,
                     int &claveProm, Pagina* &nuevoHijo) 
    {
        if (pag->esHoja) {
            return insertarEnHoja(pag, clave, valor, claveProm, nuevoHijo);
        }

        // buscar hijo
        int i = 0;
        while (i < pag->claves.size() && clave >= pag->claves[i]) i++;

        int claveSube;
        Pagina* hijoSube = nullptr;

        bool dividido = insertarRec(pag->hijos[i], clave, valor, claveSube, hijoSube);

        if (!dividido) return false;

        // insertar clave y nuevo hijo
        pag->claves.insert(pag->claves.begin() + i, claveSube);
        pag->hijos.insert(pag->hijos.begin() + i + 1, hijoSube);

        if (pag->claves.size() <= MAX_CLAVES) return false;

        // dividir nodo interno
        int mid = pag->claves.size() / 2;
        nuevaPag = new Pagina(false);

        claveProm = pag->claves[mid];

        nuevaPag->claves.assign(pag->claves.begin() + mid + 1, pag->claves.end());
        nuevaPag->hijos.assign(pag->hijos.begin() + mid + 1, pag->hijos.end());

        pag->claves.resize(mid);
        pag->hijos.resize(mid + 1);

        return true;
    }

public:
    BPlusTree() {
        raiz = new Pagina(true);  // empieza como hoja
    }

    void insertar(int clave, int valor) {
        int claveProm;
        Pagina* nuevoHijo = nullptr;

        bool dividido = insertarRec(raiz, clave, valor, claveProm, nuevoHijo);

        if (dividido) {
            Pagina* nuevaRaiz = new Pagina(false);
            nuevaRaiz->claves.push_back(claveProm);
            nuevaRaiz->hijos.push_back(raiz);
            nuevaRaiz->hijos.push_back(nuevoHijo);
            raiz = nuevaRaiz;
        }
    }

    bool buscar(int clave, int &valor) {
        Pagina* pag = raiz;

        while (!pag->esHoja) {
            int i = 0;
            while (i < pag->claves.size() && clave >= pag->claves[i]) i++;
            pag = pag->hijos[i];
        }

        // buscar en la hoja
        for (int i = 0; i < pag->claves.size(); i++) {
            if (pag->claves[i] == clave) {
                valor = pag->valores[i];
                return true;
            }
        }
        return false;
    }
};

// Ejemplo de uso
int main() {
    BPlusTree arbol;

    arbol.insertar(10, 100);
    arbol.insertar(5, 50);
    arbol.insertar(20, 200);
    arbol.insertar(15, 150);

    int valor;
    if (arbol.buscar(15, valor)) {
        cout << "15 -> " << valor << endl;
    }

    return 0;
}

